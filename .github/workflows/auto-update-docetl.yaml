name: Auto Update DocETL Chart

# This workflow is specific to the DocETL chart.
# Tracks ucbepic/docetl GitHub releases for new versions.

on:
  schedule:
    # Run daily at 00:00 UTC
    - cron: '0 0 * * *'
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: auto-update-docetl-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel running updates, queue them instead

jobs:
  check-updates:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      has_update: ${{ steps.check.outputs.has_update }}
      latest_version: ${{ steps.check.outputs.latest_version }}
      current_version: ${{ steps.check.outputs.current_version }}
      release_notes: ${{ steps.check.outputs.release_notes }}
      changelog_url: ${{ steps.check.outputs.changelog_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for new DocETL release
        id: check
        run: |
          set -euo pipefail  # Exit on error, undefined vars, pipe failures

          # Chart path
          CHART_PATH="charts/docetl/Chart.yaml"

          # Validate Chart.yaml exists
          if [ ! -f "$CHART_PATH" ]; then
            echo "::error::Chart.yaml not found at $CHART_PATH"
            exit 1
          fi

          # Get current appVersion from Chart.yaml
          CURRENT_VERSION=$(grep '^appVersion:' "$CHART_PATH" | awk '{print $2}' | tr -d '"')

          if [ -z "$CURRENT_VERSION" ]; then
            echo "::error::Failed to extract appVersion from Chart.yaml"
            exit 1
          fi

          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "::notice::Current version: $CURRENT_VERSION"

          # Get latest release from ucbepic/docetl with authentication and retry logic
          LATEST_RELEASE=$(curl -sSf \
            --retry 3 \
            --retry-delay 5 \
            --max-time 30 \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/ucbepic/docetl/releases/latest) || {
            echo "::error::Failed to fetch latest release from GitHub API after retries"
            exit 1
          }

          # Verify response is valid JSON with required fields
          if ! echo "$LATEST_RELEASE" | jq -e '.tag_name' > /dev/null 2>&1; then
            echo "::error::Invalid API response - missing tag_name field"
            echo "::debug::Response: $LATEST_RELEASE"
            exit 1
          fi

          # Check for API error messages
          if echo "$LATEST_RELEASE" | jq -e 'has("message")' > /dev/null 2>&1; then
            ERROR_MSG=$(echo "$LATEST_RELEASE" | jq -r '.message')
            echo "::error::GitHub API Error: $ERROR_MSG"
            exit 1
          fi

          # Extract version and metadata
          LATEST_VERSION=$(echo "$LATEST_RELEASE" | jq -r '.tag_name' | sed 's/^v//')
          RELEASE_DATE=$(echo "$LATEST_RELEASE" | jq -r '.published_at // "unknown"')
          RELEASE_BODY=$(echo "$LATEST_RELEASE" | jq -r '.body // "No release notes available"')
          RELEASE_URL=$(echo "$LATEST_RELEASE" | jq -r '.html_url // ""')

          # Validate version was extracted
          if [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" = "null" ]; then
            echo "::error::Failed to extract version from latest release"
            exit 1
          fi

          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          echo "changelog_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "::notice::Latest version: $LATEST_VERSION"

          # Save release notes to file for multi-line handling
          echo "$RELEASE_BODY" > /tmp/release_notes.txt || {
            echo "::error::Failed to write release notes to temporary file"
            exit 1
          }

          # Check if update is needed (skip if current is "latest" or versions match)
          if [ "$CURRENT_VERSION" = "latest" ]; then
            echo "has_update=true" >> $GITHUB_OUTPUT
            echo "::notice::Current version is 'latest', will update to track $LATEST_VERSION"
          elif [ "$CURRENT_VERSION" != "$LATEST_VERSION" ]; then
            echo "has_update=true" >> $GITHUB_OUTPUT
            echo "::notice::Update available: $CURRENT_VERSION -> $LATEST_VERSION"
          else
            echo "has_update=false" >> $GITHUB_OUTPUT
            echo "::notice::No update needed - already at latest version"
          fi

      - name: Extract changelog summary
        if: steps.check.outputs.has_update == 'true'
        id: changelog
        run: |
          RELEASE_NOTES=$(cat /tmp/release_notes.txt)

          # Create a summary of changes
          cat > /tmp/changelog_summary.md << 'EOF'
          ## New DocETL Release Available

          **Version**: ${{ steps.check.outputs.latest_version }}
          **Release Date**: ${{ steps.check.outputs.release_date }}
          **Release URL**: ${{ steps.check.outputs.changelog_url }}

          ### Release Notes

          EOF

          echo "$RELEASE_NOTES" >> /tmp/changelog_summary.md

          echo "Changelog summary created"

      - name: Upload changelog artifact
        if: steps.check.outputs.has_update == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: changelog-${{ github.run_id }}
          path: /tmp/changelog_summary.md
          retention-days: 1
          if-no-files-found: error

  notify:
    needs: check-updates
    if: needs.check-updates.outputs.has_update == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download changelog
        uses: actions/download-artifact@v4
        with:
          name: changelog-${{ github.run_id }}
          path: .
        continue-on-error: false

      - name: Create GitHub Issue for notification
        if: vars.DISABLE_ISSUE_NOTIFICATION != 'true' && vars.AUTO_MERGE != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const changelog = fs.readFileSync('changelog_summary.md', 'utf8');

            // Check if there's already an open issue for this version
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'auto-update',
              per_page: 100
            });

            const existingIssue = issues.data.find(issue =>
              issue.title.includes('${{ needs.check-updates.outputs.latest_version }}')
            );

            if (existingIssue) {
              console.log(`Issue already exists: #${existingIssue.number}`);
              return;
            }

            // Create new issue
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸš€ New DocETL Release: v${{ needs.check-updates.outputs.latest_version }}',
              body: `${changelog}\n\n---\n\n**Current Version:** ${{ needs.check-updates.outputs.current_version }}\n**New Version:** ${{ needs.check-updates.outputs.latest_version }}\n\n**Action:** A Pull Request will be created automatically to update the chart.\n\nðŸ¤– This issue was created automatically by the auto-update workflow.\n\ncc: @${{ github.repository_owner }}`,
              labels: ['auto-update', 'notification'],
              assignees: process.env.ASSIGNEES ? process.env.ASSIGNEES.split(',') : []
            });

            console.log(`Created issue: #${issue.data.number}`);
        env:
          ASSIGNEES: ${{ vars.ISSUE_ASSIGNEES || '' }}

      - name: Send email notification (optional)
        if: vars.NOTIFICATION_EMAIL != ''
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.MAIL_SERVER }}
          server_port: ${{ secrets.MAIL_PORT || '587' }}
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "[DocETL Helm Chart] New Release: v${{ needs.check-updates.outputs.latest_version }}"
          to: ${{ vars.NOTIFICATION_EMAIL }}
          from: ${{ secrets.MAIL_FROM || secrets.MAIL_USERNAME }}
          body: |
            A new version of DocETL is available!

            Current Version: ${{ needs.check-updates.outputs.current_version }}
            Latest Version: ${{ needs.check-updates.outputs.latest_version }}

            Release: ${{ needs.check-updates.outputs.changelog_url }}

            ---

            This is an automated notification from the DocETL Helm Chart repository.
            Repository: https://github.com/${{ github.repository }}

            A Pull Request or GitHub Issue has been created for this update.

  auto-release:
    needs: check-updates
    if: needs.check-updates.outputs.has_update == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Download changelog
        uses: actions/download-artifact@v4
        with:
          name: changelog-${{ github.run_id }}
          path: .
        continue-on-error: false

      - name: Install yq
        uses: mikefarah/yq@v4.40.5

      - name: Update Chart.yaml
        id: update_chart
        run: |
          set -euo pipefail

          LATEST_VERSION="${{ needs.check-updates.outputs.latest_version }}"
          CHART_PATH="charts/docetl/Chart.yaml"

          # Get current chart version using yq
          CURRENT_CHART_VERSION=$(yq eval '.version' "$CHART_PATH")

          if [ -z "$CURRENT_CHART_VERSION" ] || [ "$CURRENT_CHART_VERSION" = "null" ]; then
            echo "::error::Failed to read current chart version"
            exit 1
          fi

          echo "::notice::Current chart version: $CURRENT_CHART_VERSION"

          # Parse semver components with validation
          if ! [[ "$CURRENT_CHART_VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            echo "::error::Chart version '$CURRENT_CHART_VERSION' is not valid semver (MAJOR.MINOR.PATCH)"
            exit 1
          fi

          MAJOR="${BASH_REMATCH[1]}"
          MINOR="${BASH_REMATCH[2]}"
          PATCH="${BASH_REMATCH[3]}"

          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_CHART_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"

          echo "new_chart_version=$NEW_CHART_VERSION" >> $GITHUB_OUTPUT
          echo "::notice::New chart version: $CURRENT_CHART_VERSION -> $NEW_CHART_VERSION"

          # Create backup before modification
          cp "$CHART_PATH" "${CHART_PATH}.backup"

          # Update using yq (atomic YAML-aware updates)
          yq eval ".appVersion = \"$LATEST_VERSION\"" -i "$CHART_PATH"
          yq eval ".version = \"$NEW_CHART_VERSION\"" -i "$CHART_PATH"

          # Verify changes were applied correctly
          VERIFY_APP_VERSION=$(yq eval '.appVersion' "$CHART_PATH")
          VERIFY_CHART_VERSION=$(yq eval '.version' "$CHART_PATH")

          if [ "$VERIFY_APP_VERSION" != "$LATEST_VERSION" ]; then
            echo "::error::Failed to update appVersion (expected: $LATEST_VERSION, got: $VERIFY_APP_VERSION)"
            mv "${CHART_PATH}.backup" "$CHART_PATH"
            exit 1
          fi

          if [ "$VERIFY_CHART_VERSION" != "$NEW_CHART_VERSION" ]; then
            echo "::error::Failed to update chart version (expected: $NEW_CHART_VERSION, got: $VERIFY_CHART_VERSION)"
            mv "${CHART_PATH}.backup" "$CHART_PATH"
            exit 1
          fi

          # Clean up backup
          rm "${CHART_PATH}.backup"

          # Show changes for verification
          echo "::group::Updated Chart.yaml"
          yq eval '. | select(.version, .appVersion)' "$CHART_PATH"
          echo "::endgroup::"

      - name: Create Pull Request
        if: vars.AUTO_MERGE != 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            chore: update DocETL to v${{ needs.check-updates.outputs.latest_version }}

            Updates DocETL to version ${{ needs.check-updates.outputs.latest_version }}.

            Release: ${{ needs.check-updates.outputs.changelog_url }}

            This is an automated update created by the auto-update workflow.
          branch: auto-update/docetl-${{ needs.check-updates.outputs.latest_version }}
          delete-branch: true
          title: "chore: update DocETL to v${{ needs.check-updates.outputs.latest_version }}"
          body: |
            ## ðŸš€ Automated DocETL Release Update

            **Current Version:** ${{ needs.check-updates.outputs.current_version }}
            **New Version:** ${{ needs.check-updates.outputs.latest_version }}
            **Release:** ${{ needs.check-updates.outputs.changelog_url }}

            ---

            $(cat changelog_summary.md)

            ---

            **Notification:** This PR will trigger GitHub email notifications to all watchers and mentioned users.

            cc: @${{ github.repository_owner }} ${{ vars.PR_MENTIONS && format('| {0}', vars.PR_MENTIONS) || '' }}

            ðŸ¤– This is an automated update created by the auto-update workflow.
          labels: |
            automated
            dependencies
            auto-update
          reviewers: ${{ vars.PR_REVIEWERS }}

      - name: Validate AUTO_MERGE configuration
        if: vars.AUTO_MERGE == 'true'
        run: |
          echo "::warning::AUTO_MERGE is enabled - changes will be pushed directly to main branch"
          echo "::warning::This bypasses all code review and testing processes"

          # Check if this is production repository (adjust repo name as needed)
          if [ "${{ github.repository }}" != "thinking-and-coding/helm-charts-test" ]; then
            echo "::error::AUTO_MERGE should only be enabled in test repositories"
            echo "::error::For production, use Pull Request workflow with required reviews"
            echo "::error::Current repository: ${{ github.repository }}"
            # Uncomment the next line to enforce this check:
            # exit 1
          fi

          # Require explicit confirmation via repository variable
          if [ "${{ vars.AUTO_MERGE_CONFIRMED }}" != "true" ]; then
            echo "::error::AUTO_MERGE requires AUTO_MERGE_CONFIRMED=true variable to be set"
            echo "::error::This is a safety check to prevent accidental direct commits to main"
            echo "::error::Set this variable in GitHub repository settings: Settings > Secrets and variables > Actions > Variables"
            exit 1
          fi

          echo "::notice::AUTO_MERGE validation passed"

      - name: Commit and create release tag
        if: vars.AUTO_MERGE == 'true'
        run: |
          NEW_VERSION="${{ steps.update_chart.outputs.new_chart_version }}"
          LATEST_DOCETL_VERSION="${{ needs.check-updates.outputs.latest_version }}"

          # Commit changes
          git add charts/docetl/Chart.yaml
          git commit -m "chore: update DocETL to v$LATEST_DOCETL_VERSION

          Updates chart version to $NEW_VERSION and DocETL to v$LATEST_DOCETL_VERSION.

          Release: ${{ needs.check-updates.outputs.changelog_url }}

          ðŸ¤– Generated with Claude Code

          Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

          # Push changes to main (using --force-with-lease for safety)
          if ! git push --force-with-lease origin main; then
            echo "::error::Failed to push to main - branch may have been updated"
            echo "::error::Manual intervention required"
            exit 1
          fi

          # Create and push tag
          git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}

          DocETL version: v$LATEST_DOCETL_VERSION

          See release notes: ${{ needs.check-updates.outputs.changelog_url }}"

          git push origin "v${NEW_VERSION}"

          echo "âœ… Created and pushed tag v${NEW_VERSION}"

      - name: Summary
        run: |
          echo "## Auto Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Current Version**: ${{ needs.check-updates.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New Version**: ${{ needs.check-updates.outputs.latest_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New Chart Version**: ${{ steps.update_chart.outputs.new_chart_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Notes**: ${{ needs.check-updates.outputs.changelog_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ vars.AUTO_MERGE }}" = "true" ]; then
            echo "âœ… Changes committed and tag created automatically" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ“ Pull request created for review" >> $GITHUB_STEP_SUMMARY
          fi
